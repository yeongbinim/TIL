# Object - Theater

오브젝트 책의 1장에 있는 실습을 진행해 보았다. 그리고, 책의 전반적인 내용을 요약해보았다.

<br/>

## 목차

- [실습](#실습)
  - [1: 처음 구조](#1-처음-구조)
  - [2: TicketSeller에게 책임 위임](#2-ticketseller에게-책임-위임)
  - [3. Audience에게 책임 위임](#3-audience에게-책임-위임)
  - [4. Bag에게 책임 위임](#4-bag에게-책임-위임)
- [마치며](#마치며)
  - [1장 핵심 요약](#1장-핵심-요약)
  - [책의 요약](#책의-요약)
  - [내 생각](#내-생각)
  - [1장 후기](#1장-후기)

<br/>

## 실습

### 1: 처음 구조

[[코드 보러 가기]](https://github.com/yeongbinim/TIL/commit/a441607bf1a9d5045c956e8669c5e8c4343d5203)

<div align="center"><img width="400" alt="스크린샷 2024-11-22 오전 11 43 03" src="https://github.com/user-attachments/assets/e88f263c-eeed-45dd-9e31-a88279fa3fe4"></div>

- 문제

  - Audience와 TicketSeller가 Theater의 통제를 받는 수동적인 존재가 되었다.

    - Theater가 맘대로 Audience로부터 가방을 빼앗는다.
    - TicketSeller로 부터 TicketOffice를 빼앗아서, TicketSeller는 하는 일 없이 Theater가 모든 일을 다하고 있다.
    - 이것은 예상을 벗어난다. 예상 불가능한 코드는 이해 불가능하다.
    - Theater의 enter메서드를 이해하기 위해서는 Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어있으며 TicketSeller가 TicketOffice에서 티켓을 판매하고, TicketOffic안에 돈과 티켓이 보관돼 있다는걸 모두 기억해야 함
    - 가장 심각한 문제는 Audience 또는 TicketSeller를 변경할 경우 Theater도 같이 변경해야 한다는 점

  - 객체들 간의 결합도가 너무 높다. (= 객체 사이의 의존성이 과하다)

    - Theater가 Audience와 TicketSeller에 결합된다.

    -> 우선, TicketSeller를 자율적인 존재가 되도록 설계를 변경한다. Theater의 `enter()`로직을 TicketSeller의 `sellTo()`로 옮기고, `getTicketOffice()`를 제거한다.




작업의 흐름이 Theater에 의해 제어된다. 책임이 Theater에 집중돼 있다.

이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차지향 프로그래밍** 이라고 한다.

<br/>

### 2: TicketSeller에게 책임 위임

[[변경 코드 보러 가기]](https://github.com/yeongbinim/TIL/commit/888aa78caa67c09347e7140fa96d712080ebadba)

<div align="center"><img width="400" alt="스크린샷 2024-11-22 오전 11 43 13" src="https://github.com/user-attachments/assets/1e300ace-0d84-4fcc-bcc2-98f634fc7382"></div>


- 개선


  - Theater 클래스 어디에서도 ticketOffice에 접근하지 않는다는 사실에 주목하자.
  - Theater의 로직을 TicketSeller로 이동시켜 Theater에서 TicketOffice로의 의존성이 제거되었다.
  - TicketSeller는 `sellTo()` 기능만 제공하면 되기 때문에 자유로운 객체가 되었다.

- 아직 아쉬운 점


  - TicketSeller는 Audience의 getBag()을 통해 Audience의 Bag 인스턴스에 직접 접근한다.
  - Audience는 아직 자율적인 존재가 아님.

  -> TicketSeller의 `sellTo()`안의 로직을 Audience의 `buy()`로 옮기고, `getBag()`을 제거한다.

<br/>

### 3. Audience에게 책임 위임

[[변경 코드 보러 가기]](https://github.com/yeongbinim/TIL/commit/314a5492ea5cc87deb178b8fe398d60356016e8b)

<div align="center"><img width="400" src="https://github.com/user-attachments/assets/acf97d79-21fc-4c66-bf2b-2777bce07b49"></div>

- 개선
  - TicketSeller와 Audience 사이의 결합도가 낮아졌다. (TicketSeller가 Audience의 가방을 뺏지 않는다)
    - Audience의 구현을 수정하더라도 `buy()`를 제공한다면 cketSeller에는 영향이 미치지 않을 것이다.
  - TicketSeller때와 마찬가지로, 자기 자신의 문제를 스스로 해결하도록 코드를 변경했다.
    - 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만든 것이다.
    - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 **응집도가 높다**고 한다.

- 아쉬운점

  - Bag은 과거의 Audience처럼 스스로 자기 자신을 책임지지 않고 Audience에 의해 끌려다니는 수동적인 존재다.

  -> 이전과 동일하게 Bag의 내부 상태에 접근하는 모든 로직을 Bag 안으로 캡슐화해서 결합도를 낮출 것이다.

각 객체가 자신이 맡은 일을 스스로 처리했다. 다시 말해서 Theater에 몰려 있던 책임이 개별 객체로 이동한 것이다.

이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 **객체지향 프로그래밍** 이라고 부른다.

(단, 후반이 되면 객체지향 안에는 단순히 데이터와 프로세스를 하나의 객체 안으로 모으는 것 이상의 무엇이 있다는 점을 알게 될 것이다.)

+) 여기서 약간 헷갈렸던 점은 분명히 Audience가 Ticket에게 의존성이 생기게 되는데, 그림에 표현되지 않아서 좀 헷갈린다.

<br/>

### 4. Bag에게 책임 위임

[[변경 코드 보러 가기]](https://github.com/yeongbinim/TIL/commit/0e780773b48c8a9baf022c79df0a391b7b0e7aac)

<div align="center"><img width="400" src="https://github.com/user-attachments/assets/d188076b-f79e-4f6a-bc8d-0be8e27ae36e"/></div>

- 개선
  - hasInvitation, minusAmount, setTicket 메서드들은 더 이상 외부에서 사용되지 않고, 내부에서만 사용되기 때문에 가시성을 private로 변경
- 아쉬운점
  - TicketSeller 역시 TicketOffic의 자율권을 침해한다.
  - TicketOffice에 sellTicketTo 메서드를 추가하여 sellTo메서드의 내부 코드를 이 메서드로 옮기려하니, TicketOffice가 Audience에게 의존성이 생기게 된다. 그래서 이건 변경 안하는게 나을거 같다고 결론 내림

<br/>

## 마치며

### 1장 핵심 요약

- 객체들 간의 결합도가 너무 높다. (= 객체 사이의 의존성이 과하다) 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차지향 프로그래밍** 이라고 한다.
- 각 객체가 자신이 맡은 일을 스스로 처리했다. 다시 말해서 Theater에 몰려 있던 책임이 개별 객체로 이동한 것이다. 이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 **객체지향 프로그래밍** 이라고 부른다.
- 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있으며, 결국 설계는 트레이드오프의 산물이다.
- 설계는 코드를 배치하는 것이며, 좋은 설계는 오늘 요구하는 기능을 온전히 수행하면서 내일 쉽계 변경할 수 있는 것이다.
- 애플리케이션의 기능을 구현하기 위해 객체들이 협력하는 과정에서 **객체들은 다른 객체에 의존하게 된다**.
- 객체간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이며, 훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계이다.

<br/>

### 책의 요약

전반적으로 어떤 내용을 가지고 있는지 빠르게 훑어봤다. (저자 스타일상 하고 싶은 말은 대부분 챕터 마지막에 있다)

- 1장: 객체들에게 자유를 줘서 스스로의 데이터에 대한 **책임**을 지게 하도록 개선, 설계는 트레이드오프의 산물
- 2장: 다형성(**역할**)에 대해 말한다. 상속보다는 합성! (인터페이스의 정의된 메시지를 통해서만 협력하도록 유연한 설계, 템플릿 메서드 패턴)

- 3장: 객체지향의 핵심은 **협력, 책임, 역할**에 있다 (역할 이해를 위한 배우와 배역 예시)
- 4장: 데이터 중심 설계는 절차적 프로그래밍 방식을 따르며, 캡슐화가 무너지고 변경에 취약해지는 문제점
- 5장: **GRASP 패턴**을 통해 2장을 다시 따라가보며 **책임 주도 설계**의 이해
- 6장: 직관적이고 예측 가능하며 유연한 인터페이스 작성을 위해 따라야 하는 4가지 설계 원칙, '**디미터 법칙(내부구조 숨겨, 객체의 내부 구조가 외부로 노출되는 경우로 한정)**', '**묻지 말고 시켜라**', '**의도를 드러내는 인터페이스**', '**명령-쿼리 분리 원칙**'
- 7장: 기능 분해에서 시작해서 객체지향에 이르기까지의 변화 즉, 추상화의 역사를 다룬다.
- 8장: 의존성을 해결하는 3가지 방법으로 시작하여, 의존성을 어떻게 관리해야할지 고민거리
- 9장: 8장에서의 고민거리에 대해서 객체지향 원칙과, 패턴으로써 해결 방법을 정리
- 10장: DRY하겠다는 이유만으로 상속을 할 때의 문제점
- 11장: 상속보다는 합성
- 12장: 다형성 깊게
- 13장: 서브클래싱과 서브타이핑 - 이건 처음 보는 개념
- 14장: 설계를 일관성 있게 하기 위해 변경을 캡슐화할 수 있는 기법
- 15장: 디자인 패턴과 프레임워크의 연관성

<br/>

### 내 생각

가장 크게 얻어가는 건 3장에서의 내용이다.

- 객체지향의 핵심은 역할, 책임, 협력 3가지 관점에서 바라보는 것이다. (책임이 가장 중요함. 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정)

  - 협력: 어떤 기능을 구현하기 위한 객체들의 상호작용 (협력이라는 문맥이 있기 때문에 객체가 존재)

  - 책임: 객체가 협력에 참여하기 위해 수행하는 로직(책임이 상태를 결정해야 한다)이며, 메시지보다는 더 큰 개념

  - 역할: 객체들이 협력 안에서 수행하는 책임의 추상화(책임이 인스턴스라면, 인터페이스를 의미하는 듯)

- 행동을 결정하는 것은 협력, 상태를 결정하는 것은 행동 => 결과적으로 협력이 객체를 구성하는 행동과 상태 모두를 결정한다.
- 데이터 중심 설계가 아닌 책임 주도 설계를 해야함
  - 그리고 여기서 책임 주도 설계(협력을 만들어 내는 것)를 하기 위해서는
    1. 메세지가 객체를 결정하고
    2. 메시지에 대한 객체의 행동이 상태를 결정해야 한다.



헷갈리는 점은 이미 속성을 가진 애한테 책임을 할당한다면서 책임이 속성을 결정한다고 하는건 너무 닭이 먼저냐 알이 먼저냐 느낌이 든다.

- Movie가 calculateMovieFee 메시지를 수신할 수 있고 fee와 discountPolicy를 속성으로 가지는 이유는 협력 안에서 가격을 계산할 책임을 할당받았기 때문
  - 즉, 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.
    - 그런데, 그 책임은 정보 전문가에게 할당하는게 좋다. '영화 가격을 계산하라' 라는 메시지를 처리할 적절한 객체를 선택해야 하는데, 가격과 할인 정책을 알고있는 정보 전문가인 Movie에게 책임을 할당한다.

하지만 직접 설계를 해보니 이해가 되었다.

일단 '메시지를 보낸다'가 중요하다. 그 메시지를 처리할 정보 전문가를 선택한다기 보다는 그 메시지를 처리할 객체가 어떤 정보 전문가일지 우리가 만들어내는 느낌?이다. 아니 그것보다는 계속 두 과정을 반복하는데, 시작은 메시지여야 한다는 점?

몰라 몰라! 결국 최종 목표는 각 객체가 적절한 책임을 가지도록 설계하는 거야.

<br/>

### 1장 후기

1장을 먼저 다 본 후.. 많이 지쳤던 점은 두괄식이 아닌, '눈을 감고 ~를 상상해보자' 이렇게 예시를 들며 점점 빌드업을 쌓아가다가 설계를 하나씩 바꿔나가는데 저자가 생각하는 최선의 설계를 알려주지 않고 고민거리만 던져주며 예제가 끝나버린다는 것이다.

이 책은 각각의 Chapter가 독립적이지 않으며, 1장을 완료했을때 '우와 뭔가 얻었다!' 느낌보다는 떡밥들만 잔뜩 쌓인 느낌ㅠ

<br/>

마치 슈타인즈 게이트를 보는 기분이다. 명작이라 해서 1화를 봤는데, '오잉?' 싶은... 그런데 후반 갈수록 앞의 내용들이 '아하~' 하고 떡밥이 풀리며 흥미진진해지는 느낌?

몇 일 만에 다 보려고 했던 전략은 수정이다! 한 장 보고 오래동안 생각정리 하고, 한 장 보고 오래동안 생각정리하고 이렇게 할거임!

그리고 이 저자도 책을 쓸때 15개의 장이 서로 협력하고 각 장들이 책임을 가지는 구조로 설계한 느낌이 든다. (실제로 그랬다면...  으 아니겠지 아닐거야...)

<br/>

지금 내가 가장 보고싶은건 14장이다. 난 지금 고민거리가 필요한게 아니라 일관성있게 설계하고 싶은 맘 뿐이야...

일단 객체지향은 상상력이 많이 필요해서 꿈속의 나에게 맡기고, 낮에 이성이 많이 깨어있을 때에는 스프링이나 DB쪽 기술쪽으로 요구사항 만들어서 해결하는 거나 하자.

추성적인 걸 배운다는 것 자체가 추상적인 태스크를 세우는 느낌이야...